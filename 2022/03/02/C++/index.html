<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一.C++基础1.语言基础1.1 野指针是什么？ 概念：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）  产生原因：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。  避免办法： （1）初始化置NULL （2）申请内存后判空 （3）指针释放后置NULL （4）使用智能指针 12345678910111213141516">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面试准备">
<meta property="og:url" content="http://example.com/2022/03/02/C++/index.html">
<meta property="og:site_name" content="君落羽">
<meta property="og:description" content="一.C++基础1.语言基础1.1 野指针是什么？ 概念：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）  产生原因：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。  避免办法： （1）初始化置NULL （2）申请内存后判空 （3）指针释放后置NULL （4）使用智能指针 12345678910111213141516">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-11644e4b1417b90c2c869cf4deda4b8c_1440w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-0d5aee78b17e197b1d590769ff8af4c4_1440w.jpg">
<meta property="og:image" content="http://example.com/C++/1.png">
<meta property="og:image" content="http://example.com/C++/2.png">
<meta property="og:image" content="http://example.com/C++/3.png">
<meta property="og:image" content="http://example.com/3.png">
<meta property="article:published_time" content="2022-03-02T13:40:12.000Z">
<meta property="article:modified_time" content="2022-03-02T14:34:45.962Z">
<meta property="article:author" content="君落羽">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.zhimg.com/80/v2-11644e4b1417b90c2c869cf4deda4b8c_1440w.jpg">

<link rel="canonical" href="http://example.com/2022/03/02/C++/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++面试准备 | 君落羽</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">君落羽</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/02/C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="君落羽">
      <meta itemprop="description" content="君落羽的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="君落羽">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++面试准备
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-02 21:40:12 / 修改时间：22:34:45" itemprop="dateCreated datePublished" datetime="2022-03-02T21:40:12+08:00">2022-03-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一-C-基础"><a href="#一-C-基础" class="headerlink" title="一.C++基础"></a>一.C++基础</h1><h2 id="1-语言基础"><a href="#1-语言基础" class="headerlink" title="1.语言基础"></a>1.语言基础</h2><h3 id="1-1-野指针是什么？"><a href="#1-1-野指针是什么？" class="headerlink" title="1.1 野指针是什么？"></a>1.1 野指针是什么？</h3><ol>
<li><p><strong>概念：</strong>野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）</p>
</li>
<li><p><strong>产生原因</strong>：释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。这些我们都要注意避免。</p>
</li>
<li><p><strong>避免办法：</strong></p>
<p>（1）初始化置NULL</p>
<p>（2）申请内存后判空</p>
<p>（3）指针释放后置NULL</p>
<p>（4）使用智能指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*n); <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line">p = (<span class="type">int</span> *) <span class="built_in">realloc</span>(p, <span class="number">25</span>);<span class="comment">//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址</span></span><br><span class="line"><span class="built_in">free</span>(p);  </span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p1 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p1 = (<span class="type">int</span> *)<span class="built_in">calloc</span>(n, <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">//申请n个int内存空间同时初始化为0 </span></span><br><span class="line"><span class="built_in">assert</span>(p1 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="built_in">free</span>(p1);  </span><br><span class="line">p1 = <span class="literal">NULL</span>; <span class="comment">//释放后置空</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p2 = <span class="literal">NULL</span>; <span class="comment">//初始化置NULL</span></span><br><span class="line">p2 = <span class="keyword">new</span> <span class="type">int</span>[n]; <span class="comment">//申请n个int内存空间  </span></span><br><span class="line"><span class="built_in">assert</span>(p2 != <span class="literal">NULL</span>); <span class="comment">//判空，防错设计</span></span><br><span class="line"><span class="keyword">delete</span> []p2;  </span><br><span class="line">p2 = <span class="literal">nullptr</span>; <span class="comment">//释放后置空 </span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-2-内联函数和宏函数的区别"><a href="#1-2-内联函数和宏函数的区别" class="headerlink" title="1.2 内联函数和宏函数的区别"></a>1.2 内联函数和宏函数的区别</h3><p>区别：</p>
<ol>
<li><strong>宏定义不是函数</strong>，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；<strong>而内联函数本质上是一个函数</strong>，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。</li>
<li><strong>宏函数</strong>是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；<strong>而内联函数</strong>则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率</li>
<li><strong>宏定义</strong>是没有类型检查的，无论对还是错都是直接替换；<strong>而内联函数</strong>在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等</li>
</ol>
<p><strong>答案解析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a，b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line">MAX(a,<span class="string">&quot;Hello&quot;</span>)； <span class="comment">//错误地比较int和字符串，没有参数类型检查</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内联函数示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    a = add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b=%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上a = add(1, 2);处在编译时将被展开为：a = (a + b);</span></span><br></pre></td></tr></table></figure>

<p><strong>1、使用时的一些注意事项：</strong></p>
<ul>
<li>使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性</li>
<li>inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。</li>
<li>同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。</li>
</ul>
<p><strong>2、内联函数使用的条件：</strong></p>
<ul>
<li><p>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：</p>
</li>
<li><p>（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。</p>
</li>
<li><p>（2）如果函数体内出现循环，<strong>那么执行函数体内代码的时间要比函数调用的开销大</strong>。</p>
</li>
<li><p>（3）内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。</p>
<p><strong>在使用内联函数时，应注意如下几点：</strong>　</p>
<ol>
<li>在内联函数内<strong>不允许用循环语句和开关语句。</strong>　<br>如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。　</li>
<li><strong>内联函数的定义必须出现在内联函数第一次被调用之前。</strong></li>
</ol>
</li>
</ul>
<p>　</p>
<h3 id="1-3-运算符i-和-i的区别"><a href="#1-3-运算符i-和-i的区别" class="headerlink" title="1.3 运算符i++和++i的区别"></a>1.3 运算符i++和++i的区别</h3><p><strong>参考回答</strong></p>
<p><strong>先看到实现代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">    j += i++; <span class="comment">//先赋值后加</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i= %d, j= %d\n&quot;</span>,i, j); <span class="comment">//i= 3, j= 4</span></span><br><span class="line">    i = <span class="number">2</span>;</span><br><span class="line">    j = <span class="number">2</span>;</span><br><span class="line">    j += ++i; <span class="comment">//先加后赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i= %d, j= %d&quot;</span>,i, j); <span class="comment">//i= 3, j= 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>赋值顺序不同</strong>：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。</p>
</li>
<li><p><strong>效率不同</strong>：后置++执行速度比前置的慢6。</p>
</li>
<li><p><strong>i++ 不能作为左值(这是因为可以把i++看做是右值引用的)，而++i 可以</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p1 = &amp;（++i）；<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> *p2 = &amp;（i++）；<span class="comment">//错误</span></span><br><span class="line">++i = <span class="number">1</span>；<span class="comment">//正确</span></span><br><span class="line">i++ = <span class="number">1</span>；<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>两者都不是原子操作。</p>
</li>
</ol>
<h3 id="1-4-new和malloc的区别，各自底层实现原理。"><a href="#1-4-new和malloc的区别，各自底层实现原理。" class="headerlink" title="1.4 new和malloc的区别，各自底层实现原理。"></a>1.4 new和malloc的区别，各自底层实现原理。</h3><p><strong>参考回答</strong></p>
<ol>
<li>new是操作符，而malloc是函数。</li>
<li>new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。</li>
<li>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。</li>
<li>new可以被重载；malloc不行</li>
<li>new分配内存更直接和安全。</li>
<li><strong>new发生错误抛出异常，malloc返回null</strong></li>
</ol>
<p><strong>答案解析</strong></p>
<p><strong>malloc底层实现：</strong>当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。</p>
<p><strong>new底层实现：</strong>关键字new在调用构造函数的时候实际上进行了如下的几个步骤：</p>
<ol>
<li><p>创建一个新的对象</p>
</li>
<li><p>将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）</p>
</li>
<li><p>执行构造函数中的代码（为这个新对象添加属性）</p>
</li>
<li><p>返回新对象</p>
</li>
</ol>
<h3 id="1-5-C-中函数指针和指针函数的区别"><a href="#1-5-C-中函数指针和指针函数的区别" class="headerlink" title="1.5 C++中函数指针和指针函数的区别"></a>1.5 C++中函数指针和指针函数的区别</h3><p>   <strong>参考回答</strong></p>
<ol>
<li><p><strong>定义不同</strong><br>指针函数本质是一个函数，其返回值为指针。<br>函数指针本质是一个指针，其指向一个函数。</p>
</li>
<li><p><strong>写法不同</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指针函数：int *fun(int x,int y);</span><br><span class="line">函数指针：int (*fun)(int x,int y);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用法不同</strong></p>
</li>
</ol>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//指针函数示例</span><br><span class="line">typedef struct Data&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">&#125;Data;</span><br><span class="line">//指针函数</span><br><span class="line">Data* f(int a,int b)&#123;</span><br><span class="line">    Data * data = new Data;</span><br><span class="line">    //...</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    //调用指针函数</span><br><span class="line">    Data * myData = f(4,5);</span><br><span class="line">    //Data * myData = static_cast&lt;Data*&gt;(f(4,5));</span><br><span class="line">   //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数指针示例</span><br><span class="line">int add(int x,int y)&#123;</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br><span class="line">//函数指针</span><br><span class="line">int (*fun)(int x,int y);</span><br><span class="line">//赋值</span><br><span class="line">fun = add;</span><br><span class="line">//调用</span><br><span class="line">cout &lt;&lt; &quot;(*fun)(1,2) = &quot; &lt;&lt; (*fun)(1,2) ;</span><br><span class="line">//输出结果</span><br><span class="line">//(*fun)(1,2) =  3</span><br></pre></td></tr></table></figure>

<p>**const int *a, int const *a, const int a, int <em>const a, const int <em>const a分别是什么，有什么特点。</em></em></p>
<p>   <strong>参考回答</strong></p>
<p>const*是常量指针，*const是指针常量</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. const int a;     //指的是a是一个常量，不允许修改。</span><br><span class="line">2. const int *a;    //a指针所指向的内存里的值不变，即（*a）不变</span><br><span class="line">3. int const *a;    //同const int *a;</span><br><span class="line">4. int *const a;    //a指针所指向的内存地址不变，即a不变</span><br><span class="line">5. const int *const a;   //都不变，即（*a）不变，a也不变</span><br></pre></td></tr></table></figure>

<h2 id="2-内存"><a href="#2-内存" class="headerlink" title="2.内存"></a>2.内存</h2><h3 id="2-1-简述C-的内存管理"><a href="#2-1-简述C-的内存管理" class="headerlink" title="2.1 简述C++的内存管理"></a>2.1 简述C++的内存管理</h3><ol>
<li><p><strong>内存分配方式</strong>：</p>
<p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局&#x2F;静态存储区和常量存储区。</p>
<p><strong>栈</strong>，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。</p>
<p><strong>堆</strong>，就是那些由<strong>new</strong>分配的内存块，一般一个new就要对应一个delete。</p>
<p><strong>自由存储区</strong>，就是那些由<strong>malloc</strong>等分配的内存块，和堆是十分相似的，不过是用free来结束自己的生命。</p>
<p><strong>全局&#x2F;静态存储区</strong>，全局变量和静态变量被分配到同一块内存中</p>
<p><strong>常量存储区</strong>，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。</p>
</li>
<li><p><strong>常见的内存错误及其对策</strong>：</p>
<p>（1）内存分配未成功，却使用了它。</p>
<p>（2）内存分配虽然成功，但是尚未初始化就引用它。</p>
<p>（3）内存分配成功并且已经初始化，但操作越过了内存的边界。</p>
<p>（4）忘记了释放内存，造成内存泄露。</p>
<p>（5）释放了内存却继续使用它。</p>
<p>对策：</p>
<p>（1）定义指针时，先初始化为NULL。</p>
<p>（2）用malloc或new申请内存之后，应该<strong>立即检查</strong>指针值是否为NULL。防止使用指针值为NULL的内存。</p>
<p>（3）不要忘记为数组和动态内存<strong>赋初值</strong>。防止将未被初始化的内存作为右值使用。</p>
<p>（4）避免数字或指针的下标<strong>越界</strong>，特别要当心发生“多1”或者“少1”操作</p>
<p>（5）动态内存的申请与释放必须配对，防止<strong>内存泄漏</strong></p>
<p>（6）用free或delete释放了内存之后，立即将指针<strong>设置为NULL</strong>，防止“野指针”</p>
<p>（7）使用智能指针。</p>
</li>
</ol>
<h3 id="2-2-内存泄露及解决办法："><a href="#2-2-内存泄露及解决办法：" class="headerlink" title="2.2 内存泄露及解决办法："></a>2.2 内存泄露及解决办法：</h3><p>   <strong>什么是内存泄露？</strong></p>
<p>   简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）<strong>子类继承父类时，父类析构函数不是虚函数</strong>。（3）Windows句柄资源使用后没有释放。</p>
<p>   <strong>怎么检测？</strong></p>
<p>   第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。</p>
<p>   第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。</p>
<p>   第三：使用智能指针。</p>
<p>   第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。</p>
<h3 id="2-3-初始化为0的全局变量在bss还是data"><a href="#2-3-初始化为0的全局变量在bss还是data" class="headerlink" title="2.3 初始化为0的全局变量在bss还是data"></a>2.3 初始化为0的全局变量在bss还是data</h3><p>BSS段通常是指<strong>用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域</strong>。特点是可读写的，在程序执行之前BSS段会自动清0。</p>
<h3 id="2-4-C-中内存对齐的使用场景"><a href="#2-4-C-中内存对齐的使用场景" class="headerlink" title="2.4 C++中内存对齐的使用场景"></a>2.4 C++中内存对齐的使用场景</h3><p><strong>参考回答</strong></p>
<p>内存对齐应用于三种数据类型中：<strong>struct&#x2F;class&#x2F;union</strong></p>
<p>struct&#x2F;class&#x2F;union内存对齐原则有四个：</p>
<ol>
<li>数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。</li>
<li>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。</li>
<li>收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的”最宽基本类型成员”的整数倍。不足的要补齐。(基本类型不包括struct&#x2F;class&#x2F;uinon)。</li>
<li>sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。</li>
</ol>
<p><strong>答案解析</strong></p>
<ol>
<li><p><strong>什么是内存对齐？</strong></p>
<p>那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，<strong>编译器为结构体的每个成员按其自然边界（alignment）分配空间。</strong>各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。</p>
<p>为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，<strong>即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除</strong>，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。</p>
<p>比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
</li>
<li><p><strong>为什么要字节对齐？</strong></p>
<p>需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。</p>
<p>而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。</p>
<p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">union example &#123;  </span><br><span class="line">    int a[5];  </span><br><span class="line">    char b;  </span><br><span class="line">    double c;  </span><br><span class="line">&#125;;  </span><br><span class="line">int result = sizeof(example);  </span><br><span class="line">/*</span><br><span class="line">如果以最长20字节为准，内部double占8字节，这段内存的地址0x00000020并不是double的整数倍，只有当最小为0x00000024时可以满足整除double（8Byte）同时又可以容纳int a[5]的大小，所以正确的结果应该是result=24</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">struct example &#123;  </span><br><span class="line">    int a[5];  </span><br><span class="line">    char b;  </span><br><span class="line">    double c;  </span><br><span class="line">&#125;test_struct;</span><br><span class="line">int result = sizeof(test_struct);  </span><br><span class="line">/*</span><br><span class="line">如果我们不考虑字节对齐，那么内存地址0x0021不是double（8Byte）的整数倍，所以需要字节对齐，那么此时满足是double（8Byte）的整数倍的最小整数是0x0024，说明此时char b对齐int扩充了三个字节。所以最后的结果是result=32</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">struct example &#123;  </span><br><span class="line">    char b;  </span><br><span class="line">    double c;  </span><br><span class="line">    int a;  </span><br><span class="line">&#125;test_struct;  </span><br><span class="line">int result = sizeof(test_struct);  </span><br><span class="line">/*</span><br><span class="line">字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-C-11新特性"><a href="#3-C-11新特性" class="headerlink" title="3.C++11新特性"></a>3.C++11新特性</h2><blockquote>
<p> C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：</p>
<ol>
<li><p>语法的改进</p>
<p>（1）统一的初始化方法</p>
<p>（2）成员变量默认初始化</p>
<p>（3）auto关键字 用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）</p>
<p>（4）decltype 求表达式的类型</p>
<p>（5）智能指针 shared_ptr</p>
<p>（6）空指针 nullptr（原来NULL）</p>
<p>（7）基于范围的for循环</p>
<p>（8）右值引用和move语义 让程序员有意识减少进行深拷贝操作</p>
</li>
<li><p>标准库扩充（往STL里新加进一些模板类，比较好用）</p>
<p>（9）无序容器（哈希表） 用法和功能同map一模一样，区别在于哈希表的效率更高</p>
<p>（10）正则表达式 可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串</p>
<p>（11）Lambda表达式</p>
</li>
</ol>
</blockquote>
<h3 id="3-1-decltype"><a href="#3-1-decltype" class="headerlink" title="3.1 decltype"></a>3.1 decltype</h3><p>decltype（e)是复制 e 的类型，auto 是自动识别返回信息的具体内容大小。 </p>
<h3 id="3-2-C-11-右值引用"><a href="#3-2-C-11-右值引用" class="headerlink" title="3.2 C++11 右值引用"></a>3.2 C++11 右值引用</h3><p>概念 1：</p>
<p>左值： 可以放到等号左边的东西叫左值。</p>
<p>右值： 不可以放到等号左边的东西就叫右值。</p>
<p>概念 2：</p>
<p>左值： 可以取地址并且有名字的东西就是左值。</p>
<p>右值： 不能取地址的没有名字的东西就是右值</p>
<table>
<thead>
<tr>
<th>左值</th>
<th>l 函数名和变量名  l 返回左值引用的函数调用  l 前置自增自减表达式++i–i  l 由赋值表达式或赋值运算符连接的表达式(a&#x3D;b, a +&#x3D; b 等)  l 解引用表达式*p  l 字符串字面值”abcd</th>
</tr>
</thead>
<tbody><tr>
<td>纯右值</td>
<td>l 除字符串字面值外的字面值  l 返回非引用类型的函数调用  l 后置自增自减表达式 i++、  i–  l 算术表达式(a+b, a*b, a&amp;&amp;b, a&#x3D;&#x3D;b 等)  l 取地址表达式等(&amp;a)</td>
</tr>
<tr>
<td>将亡值</td>
<td>通常指将要被移动的对象、 T&amp;&amp;函数的返回值、 std::move 函数的返回值、转换为 T&amp;&amp;类型转换函数的返回值， 将亡值可以理解为即将要销毁的值， 通过“盗取”其它变量内存空间方式获取的值。在确保其它变量不再被使用或者即将被销毁时，  可以避免内存空间的释放和分配， 延长变量值的生命周期， 常用来完成移动构造或者移动赋值的特殊任务。</td>
</tr>
</tbody></table>
<p><strong>左值引用</strong>就是对左值进行引用的类型， <strong>右值引用</strong>就是对右值进行引用的类型， 他们都是引用，都是对象的一个别名， 并不拥有所绑定对象的堆存， 所以都必须立即初始化</p>
<p>对于左值引用， 等号右边的值必须可以取地址， 如果不能取地址， 则会编译失败， 或者可以使用 const 引用形式， 但这样就只能通过引用来读取输出， 不能修改数组， 因为是常量引用。</p>
<p>如果使用右值引用， <strong>那表达式等号右边的值需要时右值， 可以使用</strong> <strong>std::move</strong> <strong>函数强制把左值转换为右值。</strong></p>
<h3 id="3-3-深拷贝和浅拷贝"><a href="#3-3-深拷贝和浅拷贝" class="headerlink" title="3.3 深拷贝和浅拷贝"></a>3.3 深拷贝和浅拷贝</h3><p><strong>深拷贝</strong>就是再拷贝对象时， 如果<strong>被拷贝对象内部还有指针引用指向其它资源</strong>， 自己需要<strong>重新开辟一块新的内存存储资源</strong>， 而不只是简单的赋值。</p>
<p><strong>浅拷贝就是直接在拷贝对象时候，拷贝所有对象</strong>（包括目标的指针）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">Class A&#123;</span><br><span class="line"></span><br><span class="line">A();</span><br><span class="line"></span><br><span class="line">~A();</span><br><span class="line"></span><br><span class="line">A(const A&amp; a)&#123;</span><br><span class="line">A.size = a.size;           //浅拷贝的过程</span><br><span class="line"></span><br><span class="line">A.size = new int[a.size] ;      //深拷贝的过程</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">//但是这样的深拷贝复制需要存储空间，更好的想法是直接进行move操作。</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  A(int *size*) : size_(*size*)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  data_ = new int[*size*];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  A() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  A(const A &amp;*a*)                     //拷贝构造函数，深拷贝。</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    size_ = *a*.size_;</span><br><span class="line"></span><br><span class="line">    data_ = new int[size_];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;copy &quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  A(A &amp;&amp;*a*)                         //移动构造函数，拷贝之后将原有的指针指向nullptr。</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">   this-&gt;data_ = *a*.data_;        </span><br><span class="line"></span><br><span class="line">   *a*.data_ = nullptr;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; &quot;move &quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~A()                            //析构函数，对象撤销时使用。</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">   if (data_ != nullptr)</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">     delete[] data_;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int *data_;</span><br><span class="line"></span><br><span class="line">  int size_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  A a(10);</span><br><span class="line"></span><br><span class="line">  A b = a;</span><br><span class="line"></span><br><span class="line">  A c = std::move(a); // 调用移动构造函数</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不使用 std::move()， 会有很大的拷贝代价， 使用移动语义可以避免很多无用的拷贝。 </p>
<p>提供程序性能， C++所有的 STL 都实现了移动语义， 方便我们使用。</p>
<p><strong>移动语义</strong>仅针对于那些实现了移动构造函数的类的对象,对于那种基本类型 int、 float 等没有任何优化作用， 还是会拷贝， 因为它们实现没有对应的移动构造函数。</p>
<p><strong>完美转发</strong>指可以写一个接受任意实参的函数模板， 并转发到其它函数， 目标函数会收到与转发函数完全相同的实参， </p>
<p>转发函数实参是左值那目标函数实参也是左值， 转发函数实参是右值那目标函数实参也是右值。  </p>
<h3 id="3-4-新特性之模板的改进"><a href="#3-4-新特性之模板的改进" class="headerlink" title="3.4 新特性之模板的改进"></a>3.4 新特性之模板的改进</h3><p><strong>C++11</strong> <strong>之前是不允许两个右尖括号出现的， 会被认为是右移操作符， 所以需要中间加个空格进行分割， 避免发生编译错误。</strong></p>
<p><strong>直接使用using来代替typedef,可以轻松的来定义别名。</strong></p>
<h3 id="3-5-列表初始化"><a href="#3-5-列表初始化" class="headerlink" title="3.5 列表初始化"></a>3.5 列表初始化</h3><p>列表的初始化具体的好处大小是： 它是能够防止 类型窄化的。</p>
<h3 id="3-6-std-function-和-lambda-表达式"><a href="#3-6-std-function-和-lambda-表达式" class="headerlink" title="3.6 std::function 和 lambda 表达式"></a>3.6 std::function 和 lambda 表达式</h3><h3 id="3-7-C-11多并发"><a href="#3-7-C-11多并发" class="headerlink" title="3.7 C++11多并发"></a>3.7 C++11多并发</h3><h3 id="3-8-智能指针"><a href="#3-8-智能指针" class="headerlink" title="3.8  智能指针"></a>3.8  智能指针</h3><p>四种指针各自特性</p>
<p><strong>（1）auto_ptr</strong></p>
<p> auto指针存在的问题是，两个智能指针同时指向一块内存，就会两次释放同一块资源，自然报错。</p>
<p><strong>（2）unique_ptr</strong></p>
<p> unique指针规定一个智能指针独占一块内存资源。当两个智能指针同时指向一块内存，编译报错。</p>
<p> <strong>实现原理：</strong>将拷贝构造函数和赋值拷贝构造函数申明为private或delete。不允许拷贝构造函数和赋值操作符，但是支持移动构造函数，通过std:move把一个对象指针变成右值之后可以移动给另一个unique_ptr。</p>
<p><strong>（3）shared_ptr</strong></p>
<p> 共享指针可以实现多个智能指针指向相同对象，该对象和其相关资源会在引用为0时被销毁释放。</p>
<p> <strong>实现原理：</strong>有一个引用计数的指针类型变量，专门用于引用计数，使用拷贝构造函数和赋值拷贝构造函数时，引用计数加1，当引用计数为0时，释放资源。</p>
<blockquote>
<p>智能指针发生内存泄露的情况</p>
<p> <strong>当两个对象同时使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄露。</strong></p>
</blockquote>
<p><strong>注意：</strong>weak_ptr、shared_ptr存在一个问题，当两个shared_ptr指针相互引用时，那么这两个指针的引用计数不会下降为0，资源得不到释放。因此引入weak_ptr，weak_ptr是弱引用，weak_ptr的构造和析构不会引起引用计数的增加或减少。</p>
<table>
<thead>
<tr>
<th>指针</th>
<th>定义</th>
<th>使用方法</th>
</tr>
</thead>
<tbody><tr>
<td>shared_ptr</td>
<td>shared_ptr 使用了引用计数， 每一个 shared_ptr 的拷贝都指向相同的内存， 每次拷贝都会触发引用计数+1，  每次生命周期结束析构的时候引用计数-1， 在最后一个  shared_ptr 析构的时候，  内存才会释放</td>
<td></td>
</tr>
<tr>
<td>weak_ptr</td>
<td>weak_ptr 是用来监视 shared_ptr 的生命周期， 它不管理  shared_ptr 内部的指针，  它的拷贝的析构都不会影响引用计数， 纯粹  是作为一个旁观者监视  shared_ptr 中管理的资源是否存在，  可以用来返回  this 指针和解决循环引用问题。</td>
<td></td>
</tr>
<tr>
<td>unique_ptr</td>
<td>是一个独占型的智能指针，  它不允许其它智能指针共享其内部指针， 也不允许 unique_ptr 的拷贝和赋值。 使用  方法和  shared_ptr 类似，  区别是不可以拷贝</td>
<td></td>
</tr>
</tbody></table>
<h3 id="3-9-类型转换"><a href="#3-9-类型转换" class="headerlink" title="3.9 类型转换"></a>3.9 类型转换</h3><p>四种类型转换</p>
<p> C++中四种类型转换分别为<strong>const_cast、static_cast、dynamic_cast、reinterpret_cast</strong>，四种转换功能分别如下：</p>
<ol>
<li><strong>const_cast</strong></li>
</ol>
<p> 将const变量转为非const</p>
<ol start="2">
<li><strong>static_cast</strong></li>
</ol>
<p> 最常用，可以用于各种隐式转换，比如非const转const，static_cast可以用于类向上转换，但向下转换能成功但是不安全。</p>
<ol start="3">
<li><strong>dynamic_cast</strong></li>
</ol>
<p> <strong>只能用于含有虚函数的类转换</strong>，用于类向上和向下转换</p>
<p> <strong>向上转换：</strong>指子类向基类转换。</p>
<p> <strong>向下转换：</strong>指基类向子类转换。</p>
<p> 这两种转换，子类包含父类，当父类转换成子类时可能出现非法内存访问的问题。</p>
<blockquote>
<p> dynamic_cast通过判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。dynamic_cast可以做类之间上下转换，转换的时候会进行类型检查，类型相等成功转换，类型不等转换失败。运用RTTI技术，RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。在c++层面主要体现在dynamic_cast和typeid。</p>
</blockquote>
<ol start="4">
<li><strong>reinterpret_cast</strong></li>
</ol>
<p> reinterpret_cast可以做任何类型的转换，不过不对转换结果保证，容易出问题。</p>
<p><strong>注意：</strong>为什么不用C的强制转换：C的强制转换表面上看起来功能强大什么都能转，但是转换不够明确，不能进行错误检查，容易出错。</p>
<h2 id="4-面向对象"><a href="#4-面向对象" class="headerlink" title="4.面向对象"></a>4.面向对象</h2><h3 id="4-1-面向对象的三大特征"><a href="#4-1-面向对象的三大特征" class="headerlink" title="4.1  面向对象的三大特征"></a>4.1  面向对象的三大特征</h3><p><strong>参考回答</strong></p>
<p>面向对象的三大特征是<strong>封装、继承、多态</strong>。</p>
<ol>
<li><p>封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通 道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，不想给别人看到的，我们使用protected&#x2F;private把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。</p>
</li>
<li><p>继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p>
<p>三种继承方式</p>
<table>
<thead>
<tr>
<th align="center">继承方式</th>
<th align="center">private继承</th>
<th align="center">protected继承</th>
<th align="center">public继承</th>
</tr>
</thead>
<tbody><tr>
<td align="center">基类的private成员</td>
<td align="center">不可见</td>
<td align="center">不可见</td>
<td align="center">不可见</td>
</tr>
<tr>
<td align="center">基类的protected成员</td>
<td align="center">变为private成员</td>
<td align="center">仍为protected成员</td>
<td align="center">仍为protected成员</td>
</tr>
<tr>
<td align="center">基类的public成员</td>
<td align="center">变为private成员</td>
<td align="center">变为protected成员</td>
<td align="center">仍为public成员</td>
</tr>
</tbody></table>
</li>
<li><p>多态：<strong>用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数</strong>。实现多态，有二种方式，重写，重载。</p>
</li>
</ol>
<h3 id="4-2-C-的重载和重写，以及它们的区别"><a href="#4-2-C-的重载和重写，以及它们的区别" class="headerlink" title="4.2   C++ 的重载和重写，以及它们的区别"></a>4.2   C++ 的重载和重写，以及它们的区别</h3><p><strong>参考回答</strong></p>
<ol>
<li><p>重写</p>
<p><strong>是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。</strong>只有函数体不同（花括号内），派生类对象调用时会调用派生类的重写函数，不会调用被重写函数。<strong>重写的基类中被重写的函数必须有virtual修饰。</strong></p>
<p>示例如下：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual    void fun()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B :public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fun()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;B&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    A* a = new B();</span><br><span class="line">    a-&gt;fun();//输出B，A类中的fun在B类中重写，使用父类的指针指向子类的实例，并可以用父类指针来调取子类的成员函数。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    重写——也就是基类中有一个虚函数，而在派生类中也要重写一个原型（返回值、名字、参数）都相同的虚函数。不过协变例外。<strong>协变是重写的特例，基类中返回值是基类类型的引用或指针，在派生类中，返回值为派生类类型的引用或指针（特例在于它的函数返回类型不一样）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//协变测试函数</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual Base* FunTest()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;victory&quot; &lt;&lt; endl;       //返回Base类型</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual Derived* FunTest()          //返回Derived类型</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;yeah&quot; &lt;&lt; endl;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Derived d;</span><br><span class="line"></span><br><span class="line">    b.FunTest();</span><br><span class="line">    d.FunTest();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.重载</p>
<p>   <strong>我们在平时写代码中会用到几个函数但是他们的实现功能相同，但是有些细节却不同。</strong>例如：交换两个数的值其中包括（int, float,char,double)这些个类型。在C语言中我们是利用不同的函数名来加以区分。这样的代码不美观而且给程序猿也带来了很多的不便。于是在C++中人们提出了用一个函数名定义多个函数，也就是所谓的函数重载。<strong>函数重载是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    void fun() &#123;&#125;;</span><br><span class="line">    void fun(int i) &#123;&#125;;</span><br><span class="line">    void fun(int i, int j) &#123;&#125;;</span><br><span class="line">    void fun1(int i,int j)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>C++ 的重载和重写是如何实现的</strong></p>
<ol>
<li><p>C++利用<strong>命名倾轧</strong>（name mangling）技术，来改名函数名，区分参数不同的同名函数。命名倾轧是在编译阶段完成的。</p>
<p>C++定义同名重载函数：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int func(int a,double b)</span><br><span class="line">&#123;</span><br><span class="line">    return ((a)+(b));</span><br><span class="line">&#125;</span><br><span class="line">int func(double a,float b)</span><br><span class="line">&#123;</span><br><span class="line">    return ((a)+(b));</span><br><span class="line">&#125;</span><br><span class="line">int func(float a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return ((a)+(b));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>由上图可得，d代表double，f代表float，i代表int，加上参数首字母以区分同名函数。</p>
</li>
<li><p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p>
<ol>
<li>用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。</li>
<li><strong>存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针</strong>。虚表是和类对应的，虚表指针是和对象对应的。</li>
<li>多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。</li>
<li>重写用虚函数来实现，结合动态绑定。</li>
<li>纯虚函数是虚函数再加上 &#x3D; 0。</li>
<li>抽象类是指包括至少一个纯虚函数的类。</li>
</ol>
<p><strong>纯虚函数：virtual void fun()&#x3D;0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容</strong>。</p>
<h4 id="C-语言如何实现-C-语言中的重载"><a href="#C-语言如何实现-C-语言中的重载" class="headerlink" title="C 语言如何实现 C++ 语言中的重载"></a>C 语言如何实现 C++ 语言中的重载</h4><p><strong>参考答案</strong></p>
<p>c语言中不允许有同名函数，因为编译时函数命名是一样的，不像c++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：</p>
<ol>
<li><p>使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能</p>
</li>
<li><p>重载函数使用可变参数，方式如打开文件open函数</p>
</li>
<li><p>gcc有内置函数，程序使用编译函数可以实现函数重载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void func_int(void * a)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;,*(int*)a);  //输出int类型，注意 void * 转化为int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func_double(void * b)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%.2f\n&quot;,*(double*)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef void (*ptr)(void *);  //typedef申明一个函数指针</span><br><span class="line"></span><br><span class="line">void c_func(ptr p,void *param)</span><br><span class="line">&#123;</span><br><span class="line">     p(param);                //调用对应函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 23;</span><br><span class="line">    double b = 23.23;</span><br><span class="line">    c_func(func_int,&amp;a);</span><br><span class="line">    c_func(func_double,&amp;b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="4-3-说说构造函数有几种，分别什么作用"><a href="#4-3-说说构造函数有几种，分别什么作用" class="headerlink" title="4.3 说说构造函数有几种，分别什么作用"></a>4.3 说说构造函数有几种，分别什么作用</h3><p>​     C++中的构造函数可以分为4类：<strong>默认构造函数、初始化构造函数、拷贝构造函数、移动构造函数</strong>。     </p>
<pre><code> 1. 默认构造函数和初始化构造函数。 在定义类的对象的时候，完成对象的初始化工作。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //默认构造函数</span><br><span class="line">    Student()</span><br><span class="line">    &#123;</span><br><span class="line">       num=1001;</span><br><span class="line">       age=18;       </span><br><span class="line">    &#125;</span><br><span class="line">    //初始化构造函数</span><br><span class="line">    Student(int n,int a):num(n),age(a)&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    int num;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //用默认构造函数初始化对象S1</span><br><span class="line">    Student s1;</span><br><span class="line">    //用初始化构造函数初始化对象S2</span><br><span class="line">    Student s2(1002,18);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有了有参的构造了，编译器就不提供默认的构造函数。</p>
<p>2.拷贝构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;iostream.h&quot;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int *p;</span><br><span class="line">public:</span><br><span class="line">    Test(int ai,int value)</span><br><span class="line">    &#123;</span><br><span class="line">        i = ai;</span><br><span class="line">        p = new int(value);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Test()</span><br><span class="line">    &#123;</span><br><span class="line">        delete p;</span><br><span class="line">    &#125;</span><br><span class="line">    Test(const Test&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;i = t.i;</span><br><span class="line">        this-&gt;p = new int(*t.p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//复制构造函数用于复制本类的对象</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Test t1(1,2);</span><br><span class="line">    Test t2(t1);//将对象t1复制给t2。注意复制和赋值的概念不同</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>C++ 类对象的初始化顺序</strong></p>
<p>初始化顺序：</p>
<p>父类构造函数–&gt;成员类对象构造函数–&gt;自身构造函数</p>
<p>其中成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。析构顺序和构造顺序相反。</p>
<h3 id="4-4-深拷贝和浅拷贝，如何实现深拷贝"><a href="#4-4-深拷贝和浅拷贝，如何实现深拷贝" class="headerlink" title="4.4 深拷贝和浅拷贝，如何实现深拷贝"></a>4.4 深拷贝和浅拷贝，如何实现深拷贝</h3><ol>
<li>浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。</li>
<li>深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。</li>
<li>深拷贝的实现：深拷贝的拷贝构造函数和赋值运算符的重载传统实现：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">STRING( const STRING&amp; s )</span><br><span class="line">&#123;</span><br><span class="line">    //_str = s._str;</span><br><span class="line">    _str = new char[strlen(s._str) + 1];</span><br><span class="line">    strcpy_s( _str, strlen(s._str) + 1, s._str );</span><br><span class="line">&#125;</span><br><span class="line">STRING&amp; operator=(const STRING&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    if (this != &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        //this-&gt;_str = s._str;</span><br><span class="line">        delete[] _str;</span><br><span class="line">        this-&gt;_str = new char[strlen(s._str) + 1];</span><br><span class="line">        strcpy_s(this-&gt;_str, strlen(s._str) + 1, s._str);</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的拷贝构造函数我们很容易理解，<strong>先开辟出和源对象一样大的内存区域，然后将需要拷贝的数据复制到目标拷贝对象</strong> 。</p>
<p>这种方法<strong>解决了我们的指针悬挂问题，通过不断的开空间让不同的指针指向不同的内存</strong>，<strong>以防止同一块内存被释放两次的问题</strong>。</p>
<h3 id="4-5-为什么要虚析构，为什么不能虚构造"><a href="#4-5-为什么要虚析构，为什么不能虚构造" class="headerlink" title="4.5  为什么要虚析构，为什么不能虚构造"></a>4.5  为什么要虚析构，为什么不能虚构造</h3><ol>
<li><p>虚析构：<strong>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏</strong>。如果基类的析构函数不是虚函数，在特定情况下会导致派生类无法被析构。</p>
<ol>
<li>用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构</li>
<li>用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就<strong>只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数</strong>；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。</li>
</ol>
<p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
<p><strong>虚表在构造函数之前写入。</strong></p>
</li>
<li><p>不能虚构造：</p>
<ol>
<li>从存储空间角度：虚函数对应一个vtable,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）</li>
<li>从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</li>
<li>从实现上看，<strong>vtabtl 在构造函数调用后才建立，因而构造函数不可能成为虚函数</strong>。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。</li>
</ol>
</li>
</ol>
<h3 id="4-6-模板类是在什么时候实现的"><a href="#4-6-模板类是在什么时候实现的" class="headerlink" title="4.6  模板类是在什么时候实现的"></a>4.6  模板类是在什么时候实现的</h3><ol>
<li><p>模板实例化：模板的实例化分为<strong>显示实例化和隐式实例化</strong>，前者是研发人员明确的告诉模板应该使用什么样的类型去生成具体的类或函数，后者是在编译的过程中由编译器来决定使用什么类型来实例化一个模板不管是显示实例化或隐式实例化，最终生成的类或函数完全是按照模板的定义来实现的</p>
</li>
<li><p>模板具体化：当模板使用某种类型类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化。具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// #1 模板定义</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct TemplateStruct</span><br><span class="line">&#123;</span><br><span class="line">    TemplateStruct()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; sizeof(T) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// #2 模板显示实例化</span><br><span class="line">template struct TemplateStruct&lt;int&gt;;</span><br><span class="line"></span><br><span class="line">// #3 模板具体化</span><br><span class="line">template&lt;&gt; struct TemplateStruct&lt;double&gt;   //加了&lt;&gt;  变为了模板的具体化过程。</span><br><span class="line">&#123;</span><br><span class="line">    TemplateStruct() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;--8--&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    TemplateStruct&lt;int&gt; intStruct;</span><br><span class="line">    TemplateStruct&lt;double&gt; doubleStruct;</span><br><span class="line"></span><br><span class="line">    // #4 模板隐式实例化</span><br><span class="line">    TemplateStruct&lt;char&gt; llStruct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果</span><br><span class="line">4</span><br><span class="line">--8--</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-7-什么是虚继承，解决什么问题，如何实现？"><a href="#4-7-什么是虚继承，解决什么问题，如何实现？" class="headerlink" title="4.7 什么是虚继承，解决什么问题，如何实现？"></a>4.7 什么是虚继承，解决什么问题，如何实现？</h3><p>  <strong>虚继承是解决C++多重继承问题的一种手段</strong>，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。</p>
<p>虚继承可以解决多种继承前面提到的两个问题</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35158136">菱形继承问题</a></p>
<p><img src="https://pic1.zhimg.com/80/v2-11644e4b1417b90c2c869cf4deda4b8c_1440w.jpg" alt="img"></p>
<p><strong>基础示例 1</strong></p>
<p>多重继承可能会造成菱形继承的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout std::endl</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived1</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived2</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">final_derived</span> : <span class="keyword">public</span> derived1, <span class="keyword">public</span> derived2</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    final_derived object;</span><br><span class="line">    <span class="comment">//object.show(); // 去掉开头注释编译将报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">base::show</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;显示&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基础讲解 1</strong></p>
<p>当去掉上面代码的注释后，编译将会报错。我们知道<strong>derived1</strong>继承了<strong>base</strong>的<strong>show()<strong>函数作为自己的</strong>show()<strong>函数，而</strong>derived2</strong>也是一样。然后<strong>final_derived</strong>继承了<strong>derived1</strong>的<strong>show()<strong>函数，同时也继承了</strong>derived2</strong>的<strong>show()<strong>函数，当</strong>object</strong>调用**show()**函数时，</p>
<p><strong>由于编译器不知道你想调用那个show()函数，所以就报错了</strong>。</p>
<p><strong>基础示例 2</strong></p>
<p>可以使用以下方法解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout std::endl</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived1</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived2</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">final_derived</span> : <span class="keyword">public</span> derived1, <span class="keyword">public</span> derived2</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    final_derived object;</span><br><span class="line">    object.derived1::<span class="built_in">show</span>();</span><br><span class="line">    object.derived2::<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">base::show</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;显示&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基础讲解 2</strong></p>
<p><strong>在函数前面加上基类以说明调用的是哪一个函数</strong>。虽然这个方法可以解决上面的错误，但是这样写并不优雅，更主要的是，假设<strong>base</strong>有4个<strong>long long</strong>成员变量，也就是占用32字节，那么<strong>final_derived</strong>对象就占用了两倍，也就是64字节。</p>
<p>虚继承</p>
<p>虚继承可以解决上面的部分问题，但<strong>不能解决全部问题</strong>，所以使用多重继承时需要特别小心。</p>
<p><img src="https://pic1.zhimg.com/80/v2-0d5aee78b17e197b1d590769ff8af4c4_1440w.jpg" alt="img"></p>
<p><strong>基础示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout std::endl</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">final_derived</span> : <span class="keyword">public</span> derived1, <span class="keyword">public</span> derived2</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    final_derived object;</span><br><span class="line">    object.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">base::show</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;显示&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基础讲解</strong></p>
<p>上面代码可以正常运行并输出正确结果。</p>
<p>上面代码中，<strong>derived1</strong>继承<strong>base</strong>使用虚继承，<strong>derived2</strong>继承<strong>base</strong>使用虚继承，<strong>final_derived</strong>则不需要。</p>
<p><strong>虚继承使派生类除了继承基类成员作为自己的成员之外，内部还会有一份内存来保存哪些是基类的成员</strong>。当<strong>final_derived</strong>继承<strong>derived1</strong>和<strong>derived2</strong>之后，编译器根据虚继承多出来的内存，查到<strong>derived1</strong>和<strong>derived2</strong>拥有共同的基类的成员，就不会从<strong>derived1</strong>和<strong>derived2</strong>中继承这些，而是直接从共同的基类中继承成员，也就是说，<strong>final_derived</strong>直接继承<strong>base</strong>的成员，然后再继承<strong>derived1</strong>和<strong>derived2</strong>各自新增的成员。</p>
<p>这样，<strong>final_derived</strong>就不会继承两份内存。</p>
<p><strong>基础拓展</strong></p>
<p><strong>注意</strong>：如果<strong>base</strong>的成员变量都是<strong>private</strong>，那么不会有什么奇怪的问题。但是如果<strong>base</strong>有<strong>protected</strong>成员变量供派生类使用的话，就需要注意了。如果<strong>derived</strong>和<strong>derived2</strong>都操作了这个保护成员变量，这样就可能导致从<strong>derived1</strong>和<strong>derived2</strong>继承下来的操作混乱。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout std::endl</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// std::u32string</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取字符数</span></span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::<span class="type">size_t</span> m_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">derived1</span>(<span class="type">const</span> std::u32string &amp;text);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">derived2</span>(<span class="type">const</span> std::u32string &amp;text);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">final_derived</span> : <span class="keyword">public</span> derived1, <span class="keyword">public</span> derived2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">final_derived</span>(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    final_derived object;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符数是&quot;</span> &lt;&lt; object.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">derived1::<span class="built_in">derived1</span>(<span class="type">const</span> std::u32string &amp;text)</span><br><span class="line">&#123;</span><br><span class="line">    m_count = text.<span class="built_in">size</span>(); <span class="comment">// 保存字符串字符数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">derived2::<span class="built_in">derived2</span>(<span class="type">const</span> std::u32string &amp;text)</span><br><span class="line">&#123;</span><br><span class="line">    m_count = text.<span class="built_in">size</span>(); <span class="comment">// 保存字符串字符数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final_derived::<span class="built_in">final_derived</span>(<span class="type">void</span>)</span><br><span class="line">    : <span class="built_in">derived1</span>(<span class="string">U&quot;口也*啦&quot;</span>) <span class="comment">// 4个字符</span></span><br><span class="line">    , <span class="built_in">derived2</span>(<span class="string">U&quot;梁非凡&quot;</span>) <span class="comment">// 3个字符</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">base::size</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符数是3</span><br></pre></td></tr></table></figure>

<p>这种情况，<strong>derived1</strong>和<strong>derived2</strong>就应该各自保存一份<strong>m_count</strong>，也就是说不应该使用虚继承；但是如果不使用虚继承，那么就会出现开头的问题。</p>
<p><strong>所以说虚继承不能解决菱形继承的问题。这也是其他编程语言都不支持多重继承的主要原因。</strong></p>
<h3 id="4-8-C-中哪些函数不能被声明为虚函数？"><a href="#4-8-C-中哪些函数不能被声明为虚函数？" class="headerlink" title="4.8 C++ 中哪些函数不能被声明为虚函数？"></a>4.8 C++ 中哪些函数不能被声明为虚函数？</h3><p><strong>参考回答</strong></p>
<p>常见的不不能声明为虚函数的有：普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。</p>
<ol>
<li><p>为什么C++不支持普通函数为虚函数？</p>
<p>普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。</p>
</li>
<li><p>为什么C++不支持构造函数为虚函数？</p>
<p>这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）</p>
<p>构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数</p>
</li>
<li><p>为什么C++不支持内联成员函数为虚函数？</p>
<p>其实很简单，<strong>那内联函数就是为了在代码中直接展开，减少函数调用花费的代价</strong>，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，<em>inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数</em>）</p>
<p>内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数</p>
</li>
<li><p>为什么C++不支持静态成员函数为虚函数？</p>
<p>这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。</p>
<p><strong>静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别</strong></p>
</li>
<li><p>为什么C++不支持友元函数为虚函数？</p>
<p><strong>因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</strong></p>
</li>
</ol>
<h2 id="5-STL"><a href="#5-STL" class="headerlink" title="5.STL"></a>5.STL</h2><h1 id="二-数据库"><a href="#二-数据库" class="headerlink" title="二. 数据库"></a>二. 数据库</h1><h2 id="1-MySQL"><a href="#1-MySQL" class="headerlink" title="1 MySQL"></a>1 MySQL</h2><h3 id="1-1-关系型和非关系型数据库的区别你了解多少？"><a href="#1-1-关系型和非关系型数据库的区别你了解多少？" class="headerlink" title="1.1 关系型和非关系型数据库的区别你了解多少？"></a>1.1 关系型和非关系型数据库的区别你了解多少？</h3><p><strong>关系型数据库的优点</strong><br>容易理解。因为它采用了关系模型来组织数据。<br>可以保持数据的一致性。<br>数据更新的开销比较小。<br>支持复杂查询（带where子句的查询）</p>
<p><strong>非关系型数据库的优点</strong><br>不需要经过SQL层的解析，读写效率高。<br>基于键值对，数据的扩展性很好。<br>可以支持多种类型数据的存储，如图片，文档等等。  </p>
<p><strong>非关系型数据库也叫NOSQL，采用键值对的形式进行存储。</strong><br>它的读写性能很高，易于扩展，可分为内存性数据库以及文档型数据库，比如 Redis，Mongodb，HBase等等。<br><strong>适合使用非关系型数据库的场景：</strong><br>日志系统<br>地理位置存储<br>数据量巨大<br>高可用  </p>
<h3 id="1-2-InnoDB与MyISAM的区别"><a href="#1-2-InnoDB与MyISAM的区别" class="headerlink" title="1.2  InnoDB与MyISAM的区别"></a>1.2  InnoDB与MyISAM的区别</h3><p><strong>InnoDB</strong><br><strong>是 MySQL 默认的事务型存储引擎</strong>，只有在需要它不支持的特性时，才考虑使用其它存储引擎。<br>实现了四个标准的隔离级别，<strong>默认级别是可重复读(REPEATABLE READ)<strong>。在可重复读隔离级别下，<br>通过</strong>多版本并发控制(MVCC)+间隙锁(Next-Key Locking)防止幻影读</strong>。</p>
<p>主索引是<strong>聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升</strong>。<br>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适<br>应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p><strong>支持真正的在线热备份</strong>。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写<br>入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<p><strong>MyISAM</strong><br>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使<br>用它。<br>提供了大量的特性，包括压缩表、空间数据索引等。<br><strong>不支持事务。</strong><br><strong>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它</strong><br><strong>锁。</strong>但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT<br>INSERT)。</p>
<blockquote>
<p><strong>总结</strong><br>事务: InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。<br>并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。<br>外键: InnoDB 支持外键。<br>备份: InnoDB 支持在线热备份。<br>崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。<br>其它特性: MyISAM 支持压缩表和空间数据索引  </p>
</blockquote>
<h3 id="1-3-为什么使用索引？"><a href="#1-3-为什么使用索引？" class="headerlink" title="1.3 为什么使用索引？"></a>1.3 为什么使用索引？</h3><p>通过创建<strong>唯一性索引</strong>，可以保证数据库表中每一行数据的唯一性。<br>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。<br>帮助服务器避免排序和临时表<br>将随机IO变为顺序IO。<br>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p>
<h3 id="1-4-Innodb为什么要用自增id作为主键？"><a href="#1-4-Innodb为什么要用自增id作为主键？" class="headerlink" title="1.4  Innodb为什么要用自增id作为主键？"></a>1.4  Innodb为什么要用自增id作为主键？</h3><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页<br>写满，就会自动开辟一个新的页。</p>
<p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录<br>都要被插到现有索引页得中间某个位置， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的<br>索引结构，后续不得不通过OPTIMIZE TABLE（optimize table）来重建表并优化填充页面。  </p>
<h3 id="1-5-MyISAM和InnoDB实现B树索引方式的区别是什么？"><a href="#1-5-MyISAM和InnoDB实现B树索引方式的区别是什么？" class="headerlink" title="1.5 MyISAM和InnoDB实现B树索引方式的区别是什么？"></a>1.5 MyISAM和InnoDB实现B树索引方式的区别是什么？</h3><p><strong>MyISAM</strong>，B+Tree叶节点的data域存放的是数据记录的地址，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引”</p>
<p><strong>InnoDB</strong>，其数据文件本身就是索引文件，相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录，这个索引的<br>key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为“聚簇索引”或者聚集索引，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。</p>
<p>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使<br>用非单调的字段作为主键，这样会造成主索引频繁分裂。  </p>
<h3 id="1-6-MySQL是如何执行一条SQL的？具体步骤有哪些？"><a href="#1-6-MySQL是如何执行一条SQL的？具体步骤有哪些？" class="headerlink" title="1.6  MySQL是如何执行一条SQL的？具体步骤有哪些？"></a>1.6  MySQL是如何执行一条SQL的？具体步骤有哪些？</h3><p><img src="/C++/1.png"></p>
<p><strong>Server</strong>层按顺序执行sql的步骤为：</p>
<ol>
<li>客户端请求-&gt;</li>
<li>连接器（验证用户身份，给予权限） -&gt;</li>
<li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt;</li>
<li>分析器（对SQL进行词法分析和语法分析操作） -&gt;</li>
<li>优化器（主要对执行的<strong>sql</strong>优化选择最优的执行方案方法） -&gt;</li>
<li>执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）-&gt;</li>
<li>去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</li>
</ol>
<h3 id="1-7-MySQL的内部构造吗？一般可以分为哪两个部分？"><a href="#1-7-MySQL的内部构造吗？一般可以分为哪两个部分？" class="headerlink" title="1.7  MySQL的内部构造吗？一般可以分为哪两个部分？"></a>1.7  MySQL的内部构造吗？一般可以分为哪两个部分？</h3><p>可以分为服务层和存储引擎层两部分，其中：<br><strong>服务层</strong>包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及<br>所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如<br>存储过程、触发器、视图等。</p>
<p><strong>存储引擎层</strong>负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个<br>存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认的存储引擎。  </p>
<h3 id="1-8-Drop、Delete与Truncate的共同点和区别"><a href="#1-8-Drop、Delete与Truncate的共同点和区别" class="headerlink" title="1.8 Drop、Delete与Truncate的共同点和区别"></a>1.8 Drop、Delete与Truncate的共同点和区别</h3><p><strong>第一种回答</strong><br>Drop、Delete、Truncate都表示删除，但是三者有一些差别：<br>Delete用来删除表的全部或者一部分数据行，执行delete之后，用户需要提交(commmit)或者回滚<br>(rollback)来执行删除或者撤销删除，会触发这个表上所有的delete触发器。</p>
<p>Truncate删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器，TRUNCATE比<br>delete更快，占用的空间更小。</p>
<p>Drop命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触<br>发，这个命令也不能回滚。</p>
<p><strong>因此，在不再需要一张表的时候，用Drop；在想删除部分数据行时候，用Delete；在保留表而删除所有</strong><br><strong>数据的时候用Truncate。</strong></p>
<p><strong>第二种回答</strong><br>Drop直接删掉表;<br>Truncate删除表中数据，再插入时自增长id又从1开始 ;<br>Delete删除表中数据，可以加where字句。</p>
<p>具体解析<br>DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日<br>志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独<br>的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除<br>触发器。执行速度快。</p>
<ol start="2">
<li>表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而<br>DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</li>
<li>一般而言，drop &gt; truncate &gt; delete</li>
<li>应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view</li>
<li>TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。</li>
<li>truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程&#x2F;函数将被保留，但其状态会变为：invalid。</li>
<li>delete语句为DML（Data Manipulation Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</li>
<li>truncate、drop是DDL（Data Define Language),操作立即生效，原数据不放到 rollback segment中，不能回滚</li>
<li>在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束<br>影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果与事务无关，用<br>truncate即可实现。如果和事务有关，或老是想触发trigger,还是用delete。</li>
<li>Truncate table 表名 速度快,而且效率高,因为: truncate table 在功能上与不带 WHERE 子句的 DELETE<br>语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。<br>TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释<br>放。</li>
<li>TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的<br>计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，<br>请使用 DROP TABLE 语句。</li>
<li><strong>对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE</strong>，而应使用不带 WHERE 子句的<br>DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器 。</li>
</ol>
<h3 id="1-9-MySQL优化了解吗？说一下从哪些方面可以做到性能优化？"><a href="#1-9-MySQL优化了解吗？说一下从哪些方面可以做到性能优化？" class="headerlink" title="1.9 MySQL优化了解吗？说一下从哪些方面可以做到性能优化？"></a>1.9 MySQL优化了解吗？说一下从哪些方面可以做到性能优化？</h3><p>为搜索字段创建索引<br>避免使用 select *，列出需要查询的字段<br>垂直分割分表（垂直分割指的是：表<strong>的记录并不多，</strong>但是字段却很长，表占用空间很大，检索表的时候需要执行大量的IO，严重降低了性能。 这时<strong>需要把大的字段拆分到另一个表</strong>，并且该表与原表是一对一的关系。）<br>选择正确的存储引擎</p>
<h3 id="1-10-数据库隔离级别"><a href="#1-10-数据库隔离级别" class="headerlink" title="1.10 数据库隔离级别"></a>1.10 数据库隔离级别</h3><p><img src="/C++/2.png"></p>
<p><strong>未提交读</strong>，事务中发生了修改，即使没有提交，其他事务也是可见的，比如对于一个数A原来50修改<br>为100，但是我还没有提交修改，另一个事务看到这个修改，而这个时候原事务发生了回滚，这时候<br>A还是50，但是另一个事务看到的A是100.可能会导致脏读、幻读或不可重复读。</p>
<p><strong>提交读</strong>，对于一个事务从开始直到提交之前，所做的任何修改是其他事务不可见的，举例就是对于一<br>个数A原来是50，然后提交修改成100，这个时候另一个事务在A提交修改之前，读取的A是50，刚读<br>取完，A就被修改成100，这个时候另一个事务再进行读取发现A就突然变成100了；可以阻止脏读，<br>但是幻读或不可重复读仍有可能发生。</p>
<p><strong>重复读</strong>，就是对一个记录读取多次的记录是相同的，比如对于一个数A读取的话一直是A，前后两次<br>读取的A是一致的；可以阻止脏读和不可重复读，但幻读仍有可能发生。</p>
<p>可串行化读，在并发情况下，和串行化的读取的结果是一致的，没有什么不同，比如不会发生脏读和<br>幻读；该级别可以防止脏读、不可重复读以及幻读 。事务的最高级别，<strong>在每个读的数据行上，加上锁，使之不可能相互冲突，因此，会导致大量的超时</strong> </p>
<p><img src="/C++/3.png"></p>
<p>数据库并发会带来<strong>脏读、幻读、丢弃更改、不可重复读</strong>这四个常见问题，其中：</p>
<blockquote>
<p>脏读：在第一个修改事务和读取事务进行的时候，读取事务读到的数据为100，这是修改之后的数据，但是之后该事务满足一致性等特性而做了回滚操作，那么读取事务得到的结果就是脏数据了。</p>
<p>幻读：一般是T1在某个范围内进行修改操作（增加或者删除），而T2读取该范围导致读到的数据是修改之前的了，强调范围insert。</p>
<p>丢弃修改：两个写事务T1 T2同时对A&#x3D;0进行递增操作，结果T2覆盖T1，导致最终结果是1 而不是2，事务被覆盖。</p>
<p>不可重复读：T2 读取一个数据，然后T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。  </p>
</blockquote>
<blockquote>
<p><strong>不可重复读和幻读区别是什么</strong>，可以举个例子吗？<br>不可重复读的重点是<strong>修改</strong>，幻读的重点在于<strong>新增或者删除</strong>。</p>
<p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为 2000；这就是不可重复读。</p>
<p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记 录就变为了5条，这样就导致了幻读。  </p>
</blockquote>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）<br>这里需要注意的是：<strong>与 SQL 标准不同的地方在于InnoDB 存储引擎在 REPEATABLE-READ（可重读）</strong><br><strong>事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生</strong>，这与其他数据库系统(如<br>SQL Server)是不同的。所以 说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重<br>读） 已经可以完全保证事务的隔离性要 求，即达到了 SQL标准的SERIALIZABLE(可串行化)隔离级别。<br>因 为 隔 离 级 别 越 低 ， 事 务 请 求 的 锁 越 少 ， 所 以 大 部 分 数 据 库 系 统 的 隔 离 级 别 都 是 READCOMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使REPEATABLEREAD（可重读）并不会有任何性能损失。InnoDB 存储引擎在分布式事务的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。  </p>
<h3 id="1-11-数据库索引采用B-树而不是B树主要原因是"><a href="#1-11-数据库索引采用B-树而不是B树主要原因是" class="headerlink" title="1.11  数据库索引采用B+树而不是B树主要原因是"></a>1.11  数据库索引采用B+树而不是B树主要原因是</h3><p>主要原因：<strong>B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频</strong><br><strong>繁的，而B树只能中序遍历所有节点，效率太低。</strong></p>
<p><strong>文件索引和数据库索引为什么使用B+树?</strong><br>文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘<br>上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I&#x2F;O<br>的存取次数，因此B+树相比B树更为合适。</p>
<p><strong>数据库系统巧妙利用了局部性原理与磁盘预读原理</strong>，将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。最重要的是，B+树还有一个最大的好处：方便扫库。</p>
<p><strong>B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query</strong>非常方便，而B树不支持，这是数据库选用B+树的最主要原因。</p>
<p><strong>B+树查找效率更加稳定</strong>，B树有可能在中间节点找到数据，稳定性不够。</p>
<p><strong>B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B树更小。</strong>如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键<br>字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；<br><strong>B+tree的查询效率更加稳定</strong>：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字<br>的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相<br>同，导致每一个数据的查询效率相当；  </p>
<h3 id="1-12-听说过视图吗？那游标呢？"><a href="#1-12-听说过视图吗？那游标呢？" class="headerlink" title="1.12 听说过视图吗？那游标呢？"></a>1.12 听说过视图吗？那游标呢？</h3><p><strong>视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集</strong>，具有和物理表相同的功能。</p>
<blockquote>
<p>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。使用视图可以简化复杂的 sql 操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。</p>
<p>视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。</p>
<p>创建视图：create view xxx as xxxx  </p>
</blockquote>
<p><strong>游标是对查询出来的结果集作为一个单元来有效的处理。一般不使用游标，但是需要逐条处理数据的时</strong><br><strong>候，游标显得十分重要。</strong>  </p>
<h3 id="1-13-MySQL中为什么要有事务回滚机制ROLLBACK-？"><a href="#1-13-MySQL中为什么要有事务回滚机制ROLLBACK-？" class="headerlink" title="1.13 MySQL中为什么要有事务回滚机制ROLLBACK ？"></a>1.13 MySQL中为什么要有事务回滚机制ROLLBACK ？</h3><p>在 MySQL 中，<strong>恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个</strong><br><strong>回滚日志中，然后在对数据库中的对应行进行写入。 当事务已经被提交之后，就无法再次回滚了。</strong></p>
<p>回滚日志作用：<br>1)<strong>能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息</strong><br>2) <strong>在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查</strong><br><strong>询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们</strong><br><strong>需要先写日志后写数据库的主要原因</strong>。 </p>
<h3 id="1-14-数据库悲观锁和乐观锁的原理和应用场景分别有什么？"><a href="#1-14-数据库悲观锁和乐观锁的原理和应用场景分别有什么？" class="headerlink" title="1.14  数据库悲观锁和乐观锁的原理和应用场景分别有什么？"></a>1.14  数据库悲观锁和乐观锁的原理和应用场景分别有什么？</h3><p><strong>悲观锁，先获取锁，再进行业务操作</strong>，一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数<br>据加锁，避免其他事务意外修改数据。当数据库执行SELECT … FOR UPDATE时会获取被select中的数据行的行锁，<strong>select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用</strong>。</p>
<p><strong>乐观锁，先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过</strong>。Java 并发包中的<br><strong>AtomicFieldUpdater</strong> 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。  </p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/40211594">https://zhuanlan.zhihu.com/p/40211594</a></p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a><strong>乐观锁</strong></h2><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<strong>write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>
<h2 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a><strong>两种锁的使用场景</strong></h2><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p>
<h2 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a><strong>乐观锁常见的两种实现方式</strong></h2><blockquote>
<p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong></p>
</blockquote>
<p><strong>1. 版本号机制</strong></p>
<p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p><strong>举一个简单的例子：</strong><br>假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p>
<ol>
<li>操作员 A 此时将其读出（ version&#x3D;1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li>
<li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version&#x3D;1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li>
<li>操作员 A 完成了修改工作，将数据版本号加一（ version&#x3D;2 ），连同帐户扣除后余额（ balance&#x3D;$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li>
<li>操作员 B 完成了操作，也将版本号加一（ version&#x3D;2 ）试图向数据库提交数据（ balance&#x3D;$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li>
</ol>
<p>这样，就避免了操作员 B 用基于 version&#x3D;1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p>
<p><strong>2. CAS算法</strong></p>
<p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。<strong>CAS算法</strong>涉及到三个操作数</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B</li>
</ul>
<p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p>
<h2 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a><strong>乐观锁的缺点</strong></h2><blockquote>
<p>ABA 问题是乐观锁一个常见的问题</p>
</blockquote>
<p><strong>1 ABA 问题</strong></p>
<p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>“ABA”问题。</strong></p>
<p><strong>2 循环时间长开销大。</strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</p>
<p><strong>3 只能保证一个共享变量的原子操作</strong></p>
</blockquote>
<h3 id="1-15-MySQL索引主要使用的两种数据结构是什么？"><a href="#1-15-MySQL索引主要使用的两种数据结构是什么？" class="headerlink" title="1.15 MySQL索引主要使用的两种数据结构是什么？"></a>1.15 MySQL索引主要使用的两种数据结构是什么？</h3><p><strong>哈希索引</strong>，对于哈希索引来说，底层的数据结构肯定是哈希表，因此在绝大多数需求为单条记录查询<br>的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引<br><strong>BTree索引</strong>，Mysql的BTree索引使用的是B树中的B+Tree，BTREE索引就是一种将索引值按一定的算<br>法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获<br>取leaf。<br><strong>但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。</strong>  </p>
<h3 id="1-16-数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？"><a href="#1-16-数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？" class="headerlink" title="1.16 数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？"></a>1.16 数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？</h3><p><strong>分库与分表的目的在于，减小数据库的单库单表负担，提高查询性能，缩短查询时间。</strong><br><strong>通过分表</strong>，可以减少数据库的单表负担，将压力分散到不同的表上，同时因为不同的表上的数据量少<br>了，起到提高查询性能，缩短查询时间的作用，此外，可以很大的缓解表锁的问题。分表策略可以归纳为垂直拆分和水平拆分：<br><strong>水平分表</strong>：取模分表就属于随机分表，而时间维度分表则属于连续分表。如何设计好垂直拆分，我的建议：将不常用的字段单独拆分到另外一张扩展表. 将大文本的字段单独拆分到另外一张扩展表, 将不经常修改的字段放在同一张表中，将经常改变的字段放在另一张表中。对于海量用户场景，可以考虑取模分表，数据相对比较均匀，不容易出现热点和并发访问的瓶颈。</p>
<p><strong>库内分表</strong>，仅仅是解决了单表数据过大的问题，但并没有把单表的数据分散到不同的物理机上，因此并不能减轻 MySQL 服务器的压力，仍然存在同一个物理机上的资源竞争和瓶颈，包括 CPU、内存、磁盘IO、网络带宽等。</p>
<p><strong>分库与分表带来的分布式困境与应对之策</strong><br>数据迁移与扩容问题—-一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。<br>分页与排序问题—-需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。  </p>
<h3 id="1-17-MySQL中有四种索引类型，可以简单说说吗？"><a href="#1-17-MySQL中有四种索引类型，可以简单说说吗？" class="headerlink" title="1.17  MySQL中有四种索引类型，可以简单说说吗？"></a>1.17  MySQL中有四种索引类型，可以简单说说吗？</h3><p><strong>FULLTEXT</strong> ：即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER<br>TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索<br>引。</p>
<p><strong>HASH</strong> ：由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。 HASH索<br>引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件<br>的，即只在“&#x3D;”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</p>
<p><strong>BTREE</strong> ：BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每<br>次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类<br>型。</p>
<p><strong>RTREE</strong> ：RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有<br>MyISAM、BDb、InnoDb、NDb、Archive几种。 相对于BTREE，RTREE的优势在于范围查找。    </p>
<h3 id="1-18-假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？"><a href="#1-18-假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？" class="headerlink" title="1.18  假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？"></a>1.18  假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？</h3><p>设计良好的<strong>数据库结构，允许部分数据冗余，尽量避免join查询，提高效率</strong>。</p>
<p>选择合适的<strong>表字段数据类型和存储引擎</strong>，适当的添加索引。</p>
<p>MySQL库<strong>主从读写分离</strong>。</p>
<p>找规律分表，<strong>减少单表中的数据量提高查询速度</strong>。</p>
<p>添加<strong>缓存机制</strong>，比如Memcached，Apc等。</p>
<p>不经常改动的页面，<strong>生成静态页面</strong>。</p>
<p><strong>书写高效率的SQL</strong>。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM<br>TABLE。  </p>
<h3 id="1-19-覆盖索引是什么？"><a href="#1-19-覆盖索引是什么？" class="headerlink" title="1.19 覆盖索引是什么？"></a>1.19 覆盖索引是什么？</h3><p><strong>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称 之为“覆盖索引”。</strong><br>我们知道在InnoDB存储引 擎中，如果不是主键索引，叶子节点存储的是<strong>主键+列值</strong>。最终还是要“回<br>表”，也就是要通过主键再查找一次,这样就 会比较慢。<strong>覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</strong>  </p>
<h3 id="1-20-数据库中的主键、超键、候选键、外键是什么？"><a href="#1-20-数据库中的主键、超键、候选键、外键是什么？" class="headerlink" title="1.20  数据库中的主键、超键、候选键、外键是什么？"></a>1.20  数据库中的主键、超键、候选键、外键是什么？</h3><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键<br>候选键：不含有多余属性的超键称为候选键。也就是在候选键中，若再删除属性，就不是键了！<br>主键：用户选作元组标识的一个候选键程序主键<br>外键：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。  </p>
<p><img src="/3.png" alt="img"></p>
<p>超键：于是我们从例子中可以发现 学号是标识学生实体的唯一标识。那么该元组的超键就为学号。<br>除此之外我们还可以把它跟其他属性组合起来，比如：(学号，性别)，(学号，年龄)<br>候选键：根据例子可知，学号是一个可以唯一标识元组的唯一标识，因此学号是一个候选键，实际<br>上，候选键是超键的子集，比如 （学号，年龄）是超键，但是它不是候选键。因为它还有了额外的<br>属性。<br>主键：简单的说，例子中的元组的候选键为学号，但是我们选定他作为该元组的唯一标识，那么学号<br>就为主键。<br>外键是相对于主键的，比如在学生记录里，主键为学号，在成绩单表中也有学号字段，因此学号为成<br>绩单表的外键，为学生表的主键。<br><strong>主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的。</strong>  </p>
<h3 id="1-21-数据库三大范式精讲"><a href="#1-21-数据库三大范式精讲" class="headerlink" title="1.21  数据库三大范式精讲"></a>1.21  数据库三大范式精讲</h3><p><strong>第一范式</strong><br>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数<br>据库就不是关系数据库。 所谓第一范式（1NF）是指<strong>数据库表的每一列都是不可分割的基本数据项</strong>，同<br>一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。</p>
<p>如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之<br>间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p>
<p>简而言之，<strong>第一范式就是无重复的列</strong>。</p>
<p><strong>第二范式</strong><br>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第<br>一范式（1NF）。第二范式（2NF<strong>）要求数据库表中的每个实例或行必须可以被惟一地区分</strong>。</p>
<p>为实现区分通常需要为表加上一个列，以存储各个实例的<strong>惟一标识</strong>。这个惟一属性列被称为主关键字或<br>主键、主码。 第二范式（2NF）要求实体的属性完全依赖于主关键字。</p>
<p>所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一<br>部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表<br>加上一个列，以存储各个实例的惟一标识。</p>
<p>简而言之，第二范式就是非主属性部分依赖于主关键字。</p>
<p><strong>第三范式</strong><br>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，<strong>第三范式（3NF）要求一个数据库表</strong><br><strong>中不包含已在其它表中已包含的非主关键字信息</strong>。</p>
<p>例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么<br>在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表<br>中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。  </p>
<blockquote>
<p>数据库三大范式精要总结<br>（1）简单归纳：<br>第一范式（1NF）：字段不可分；<br>第二范式（2NF）：有主键，非主键字段依赖主键；<br>第三范式（3NF）：非主键字段不能相互依赖。<br>（2）解释：<br>1NF：原子性。 字段不可再分,否则就不是关系数据库；<br>2NF：唯一性 。一个表只说明一个事物；<br>3NF：每列都与主键有直接关系，不存在传递依赖  </p>
</blockquote>
<h3 id="1-22-事务四大特性（ACID）原子性、一致性、隔离性、持久性？"><a href="#1-22-事务四大特性（ACID）原子性、一致性、隔离性、持久性？" class="headerlink" title="1.22 事务四大特性（ACID）原子性、一致性、隔离性、持久性？"></a>1.22 事务四大特性（ACID）原子性、一致性、隔离性、持久性？</h3><p><strong>第一种回答</strong><br><strong>原子性</strong>：一个事务（transaction）中的所有操作，<strong>要么全部完成，要么全部不完成</strong>，不会结束在中间某<br>个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
<p><strong>一致性</strong>：<strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏</strong>。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
<p><strong>隔离性</strong>：<strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力</strong>，隔离性可以防止多个事务并发<br>执 行 时 由 于 交 叉 执 行 而 导 致 数 据 的 不 一 致 。 事 务 隔 离 分 为 不 同 级 别 ， 包 括 读 未 提 交 （ Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
<p><strong>持久性</strong>：事务处理结束后，<strong>对数据的修改就是永久的</strong>，即便系统故障也不会丢失。 </p>
<h3 id="1-23-SQL中的NOW-和CURRENT-DATE-两个函数有什么区别？"><a href="#1-23-SQL中的NOW-和CURRENT-DATE-两个函数有什么区别？" class="headerlink" title="1.23  SQL中的NOW()和CURRENT_DATE()两个函数有什么区别？"></a>1.23  SQL中的NOW()和CURRENT_DATE()两个函数有什么区别？</h3><p>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。<br>CURRENT_DATE（）仅显示当前年份，月份和日期。  </p>
<h2 id="2-Redis"><a href="#2-Redis" class="headerlink" title="2 Redis"></a>2 Redis</h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/01/Balser/" rel="prev" title="Balser相机">
      <i class="fa fa-chevron-left"></i> Balser相机
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-C-%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">一.C++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">1.语言基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E9%87%8E%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 野指针是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 内联函数和宏函数的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E8%BF%90%E7%AE%97%E7%AC%A6i-%E5%92%8C-i%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 运算符i++和++i的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%90%84%E8%87%AA%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%82"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4 new和malloc的区别，各自底层实现原理。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-C-%E4%B8%AD%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.5 C++中函数指针和指针函数的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%86%85%E5%AD%98"><span class="nav-number">1.2.</span> <span class="nav-text">2.内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%AE%80%E8%BF%B0C-%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 简述C++的内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9A"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 内存泄露及解决办法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BA0%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%9C%A8bss%E8%BF%98%E6%98%AFdata"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 初始化为0的全局变量在bss还是data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-C-%E4%B8%AD%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 C++中内存对齐的使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-C-11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.3.</span> <span class="nav-text">3.C++11新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-decltype"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 decltype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-C-11-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 C++11 右值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 深拷贝和浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 新特性之模板的改进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.5 列表初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-std-function-%E5%92%8C-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.3.6.</span> <span class="nav-text">3.6 std::function 和 lambda 表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-C-11%E5%A4%9A%E5%B9%B6%E5%8F%91"><span class="nav-number">1.3.7.</span> <span class="nav-text">3.7 C++11多并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.3.8.</span> <span class="nav-text">3.8  智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.3.9.</span> <span class="nav-text">3.9 类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.4.</span> <span class="nav-text">4.面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1  面向对象的三大特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-C-%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2   C++ 的重载和重写，以及它们的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-C-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">C 语言如何实现 C++ 语言中的重载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E8%AF%B4%E8%AF%B4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%8C%E5%88%86%E5%88%AB%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 说说构造函数有几种，分别什么作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4 深拷贝和浅拷贝，如何实现深拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%99%9A%E6%9E%90%E6%9E%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%99%9A%E6%9E%84%E9%80%A0"><span class="nav-number">1.4.5.</span> <span class="nav-text">4.5  为什么要虚析构，为什么不能虚构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%98%AF%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">1.4.6.</span> <span class="nav-text">4.6  模板类是在什么时候实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E7%BB%A7%E6%89%BF%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">1.4.7.</span> <span class="nav-text">4.7 什么是虚继承，解决什么问题，如何实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-C-%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">1.4.8.</span> <span class="nav-text">4.8 C++ 中哪些函数不能被声明为虚函数？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-STL"><span class="nav-number">1.5.</span> <span class="nav-text">5.STL</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">2.</span> <span class="nav-text">二. 数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-MySQL"><span class="nav-number">2.1.</span> <span class="nav-text">1 MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%85%B3%E7%B3%BB%E5%9E%8B%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1 关系型和非关系型数据库的区别你了解多少？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-InnoDB%E4%B8%8EMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.2  InnoDB与MyISAM的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">2.1.3.</span> <span class="nav-text">1.3 为什么使用索引？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-Innodb%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%87%AA%E5%A2%9Eid%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="nav-number">2.1.4.</span> <span class="nav-text">1.4  Innodb为什么要用自增id作为主键？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-MyISAM%E5%92%8CInnoDB%E5%AE%9E%E7%8E%B0B%E6%A0%91%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.1.5.</span> <span class="nav-text">1.5 MyISAM和InnoDB实现B树索引方式的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-MySQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1SQL%E7%9A%84%EF%BC%9F%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">2.1.6.</span> <span class="nav-text">1.6  MySQL是如何执行一条SQL的？具体步骤有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-MySQL%E7%9A%84%E5%86%85%E9%83%A8%E6%9E%84%E9%80%A0%E5%90%97%EF%BC%9F%E4%B8%80%E8%88%AC%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E5%93%AA%E4%B8%A4%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F"><span class="nav-number">2.1.7.</span> <span class="nav-text">1.7  MySQL的内部构造吗？一般可以分为哪两个部分？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-Drop%E3%80%81Delete%E4%B8%8ETruncate%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.8.</span> <span class="nav-text">1.8 Drop、Delete与Truncate的共同点和区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-MySQL%E4%BC%98%E5%8C%96%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%88%B0%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">2.1.9.</span> <span class="nav-text">1.9 MySQL优化了解吗？说一下从哪些方面可以做到性能优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">2.1.10.</span> <span class="nav-text">1.10 数据库隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E9%87%87%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AFB%E6%A0%91%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%E6%98%AF"><span class="nav-number">2.1.11.</span> <span class="nav-text">1.11  数据库索引采用B+树而不是B树主要原因是</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-12-%E5%90%AC%E8%AF%B4%E8%BF%87%E8%A7%86%E5%9B%BE%E5%90%97%EF%BC%9F%E9%82%A3%E6%B8%B8%E6%A0%87%E5%91%A2%EF%BC%9F"><span class="nav-number">2.1.12.</span> <span class="nav-text">1.12 听说过视图吗？那游标呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-13-MySQL%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E6%9C%BA%E5%88%B6ROLLBACK-%EF%BC%9F"><span class="nav-number">2.1.13.</span> <span class="nav-text">1.13 MySQL中为什么要有事务回滚机制ROLLBACK ？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.1.14.</span> <span class="nav-text">1.14  数据库悲观锁和乐观锁的原理和应用场景分别有什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">2.2.</span> <span class="nav-text">悲观锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">2.3.</span> <span class="nav-text">乐观锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.4.</span> <span class="nav-text">两种锁的使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">2.5.</span> <span class="nav-text">乐观锁常见的两种实现方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">2.6.</span> <span class="nav-text">乐观锁的缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-MySQL%E7%B4%A2%E5%BC%95%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.6.1.</span> <span class="nav-text">1.15 MySQL索引主要使用的两种数据结构是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%88%86%E5%BA%93%E5%92%8C%E5%88%86%E8%A1%A8%E5%91%A2%EF%BC%9F%E9%83%BD%E6%94%BE%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%93%E6%88%96%E8%80%85%E4%B8%80%E5%BC%A0%E8%A1%A8%E4%B8%AD%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F"><span class="nav-number">2.6.2.</span> <span class="nav-text">1.16 数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-17-MySQL%E4%B8%AD%E6%9C%89%E5%9B%9B%E7%A7%8D%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4%E5%90%97%EF%BC%9F"><span class="nav-number">2.6.3.</span> <span class="nav-text">1.17  MySQL中有四种索引类型，可以简单说说吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-18-%E5%81%87%E5%A6%82%E4%BD%A0%E6%89%80%E5%9C%A8%E7%9A%84%E5%85%AC%E5%8F%B8%E9%80%89%E6%8B%A9MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%8C%E4%B8%80%E5%A4%A9%E4%BA%94%E4%B8%87%E6%9D%A1%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%A2%9E%E9%87%8F%EF%BC%8C%E9%A2%84%E8%AE%A1%E8%BF%90%E7%BB%B4%E4%B8%89%E5%B9%B4%EF%BC%8C%E4%BD%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5%EF%BC%9F"><span class="nav-number">2.6.4.</span> <span class="nav-text">1.18  假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-19-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.6.5.</span> <span class="nav-text">1.19 覆盖索引是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-20-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E4%B8%BB%E9%94%AE%E3%80%81%E8%B6%85%E9%94%AE%E3%80%81%E5%80%99%E9%80%89%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.6.6.</span> <span class="nav-text">1.20  数据库中的主键、超键、候选键、外键是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-21-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%E7%B2%BE%E8%AE%B2"><span class="nav-number">2.6.7.</span> <span class="nav-text">1.21  数据库三大范式精讲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-22-%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%81%E9%9A%94%E7%A6%BB%E6%80%A7%E3%80%81%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%9F"><span class="nav-number">2.6.8.</span> <span class="nav-text">1.22 事务四大特性（ACID）原子性、一致性、隔离性、持久性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-23-SQL%E4%B8%AD%E7%9A%84NOW-%E5%92%8CCURRENT-DATE-%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.6.9.</span> <span class="nav-text">1.23  SQL中的NOW()和CURRENT_DATE()两个函数有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Redis"><span class="nav-number">2.7.</span> <span class="nav-text">2 Redis</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">君落羽</p>
  <div class="site-description" itemprop="description">君落羽的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">君落羽</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
